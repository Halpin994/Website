@model IEnumerable<MvcWebsite.Models.CommentModel>

<!DOCTYPE html>

<html>
<head>
    <meta name="viewport" content="width=device-width" />
    <title>Projects</title>
</head>
<body>

    <div>
        <h3>Projects</h3>
        <div align="center">
            <h3>ASP.NET MVC Website</h3>
        </div>
        <div align="center"><h4>• The Website <a href='http://conorhalpin.eu:8080/job/MvcWebsite/'><img src='http://35.161.104.133:8080/job/MvcWebsite/badge/icon'></a></h4></div>
        <p>
            This website was built in order to practice .NET web development, backend development and showcase my work. I chose the MVC design pattern for my website as it seems to be very popular and in demand at the moment. It also provides a number of advantages over the use of other design patterns. The MVC design pattern separates the components of the website into 3 parts called the Model, View and Controller. I started out by completing a Movie Database tutorial. From there I started building my website and deleted any items associated with the Movie DB which I no longer needed.
        </p>
        <p><b>Model</b></p>
        <p>
            The Model represents the data inside the website. This website has a model for the comments. It defines a comment as an object that has an id, user name, name of the page (view) the comment was posted on and finally the comment itself. Models know nothing about the Views or Controllers. This is advantageous as the model can be reusable without modification. If the comments held a profile picture I could create a view that displays the comments with just usernames. I could also create a view which displays the comments with just a profile picture if it was requested by the project lead. This can be done without changing the comment model, making it very reusable.
        </p>
        <p><b>View</b></p>
        <p>
            The View represents the actual page we are looking at written in C# html. It determines how the page is displayed. It also sends user input to the controller. So If I am currently on the Index page and want to view the Projects page, I click the link to the Projects page. The view tells the controller to display the Projects view. The controller then provides us with the Project view. C# html supports server side code whereas raw html does not. Because of this, comments are loaded when the view is requested. They are not hard coded into the webpage.
        </p>
        <p><b>Controller</b></p>
        <p>
            The Controller provides the model data to the view. It also handles the user input which the view sends to it. The controller is dependent on the view and model. How it works with the model and view components: The controller is told load the Index page. It gets the comments and sends them to the view. Then displays the view.
        </p>
        <div align="center"><h4>• Automatic Deployment System</h4></div>
        <p>
            Having to manually deploy a website to a server each time a change is made is not efficient or necessary. I decided to automatically deploy the website because of this.
        </p>
        <p><b>Github</b> - <a href="https://github.com/Halpin994/Website">Repo</a></p>
        <p>
            I began by creating a simple website using the MVC design pattern. I pushed this up to my github so it had a repository online which will be very important to this system later on. Github provides a number of useful services besides this, including the use of branches. Which are used to safely implement new features.
        </p>
        <p><b>Jenkins</b> - <a href="http://www.conorhalpin.eu:8080">Dashboard</a></p>
        <p>
            Jenkins is an automation service for continuous deployment which accelerates the development process. In the beginning I linked Jenkins to the location of MSBuild.exe on my local system so it can later build my project. I then created a job. Each job has its own workspace and is basically a list of tasks you want Jenkins to perform. The job was set to poll my github repo every 2 minutes to check for any changes. If a change is detected, the job will pull down the repo into the workspace folder specific to the job.
        </p>
        <p>
            After the project has been pulled down I need to generate the package, bin and obj folders again as I stopped commiting them to github because it is unnecessary. Nuget does this for us in visual studio so I downloaded the nuget.exe and added a build step windows batch command, the command links to the location of the nuget.exe then runs a restore on the project solution which I specify by quoting its location.
        </p>
        <p>
            Once the nuget restore has been performed a build step will attempt to build the project using the solution file in the project and MSBuild.exe. This removes the need to use Visual Studio to build the project on a server for example. Jenkins had to be linked to the latest MSBuild provided with .Net v4.5 as my application uses .Net v4.5 features.
        </p>
        <p><b>IIS 7</b></p>
        <p>
            IIS 7 is a web server created by Microsoft. I use this to serve my website through a predefined port. An application pool was created in IIS which supports the use of .Net v4.0. I then added my site to the list of websites. It was set up by specifying the application pool I want to use and the physical path of my website. This was linked to the project in the Jenkins workspace and not the project located in my Visual Studio Projects folder. The application pool had to be set to enable 32 bit applications before it would serve my website successfully. I could now see my website through localhost:(port number) in my browser.
        </p>
        <p>
            I tested the system by making a visible change to the website, pushing it up to my repo and waiting for Jenkins to detect it. After it detected the change, it pulled it down and built it. IIS was already pointing at the workspace so all I had to do then was refresh my page and I could see the change I made. Now that I knew I could successfully set the system up I decided to host the website somewhere else other than my own computer.
        </p>
        <p><b>Amazon Web Services - EC2 server</b></p>
        <p>
            I chose to use amazon web services to host my website as they provide an EC2 server for free for the first year. The EC2 server is an external computer I can connect to and use through my computer. Once I had my EC2 server running I proceeded to install the latest .Net framework, Jenkins and IIS 7. These were set up the same as before. I then forwarded the ports which IIS is serving the website through and also the port which Jenkins is served through. This enables me to modify and view Jenkins services from my local machine provided I am signed in.
        </p>
        <p><b>Downstream Project</b></p>
        <p>
            A second job was created on Jenkins to build my website. A post build step was added to the first jenkins job to trigger the second job only if its build is successful. The second job does not poll my repo for changes. If the first job's build is successful, the second job pulls down the repo and builds it again into another workspace. IIS was then modified to point at this workspace to prevent an unsuccessful build from breaking the website. Now only the latest working build will be served.
        </p>
        <p><b>Domain</b></p>
        <p>
            The domain conorhalpin.eu was purchased and then pointed at my EC2 servers IP address along with the port IIS is constantly serving the website through.
        </p>
        <div align="center"><h4>• Jenkins Plugins</h4></div>
        <p>
            A plugin was installed in Jenkins which enables me to embed the current build status of whatever job I choose. I used the first job of the website for the website plugin because the status of the second will always be successful. If you click on the plugin at the top of this page you will be taken to the job page associated with the website. You can also see and click the plugin for the Message Broker service below. There you can view the changes I have made through github commits and the build history.
        </p>
        <div align="center"><h4>• Dependancy Injection</h4></div>
        <p>...</p>
        <p><b>Interfaces</b></p>
        <p>...</p>
        <p><b>Settings</b></p>
        <p>...</p>
        <div align="center"><h4>• Logger</h4></div>
        <p>...</p>
        <div align="center"><h4>• Comment System</h4></div>
        <p>...</p>
        <p><b>Comment Model</b></p>
        <p>...</p>
        <p><b>Message Broker Service</b> <a href='http://www.conorhalpin.eu:8080/job/MessageBroker/'><img src='http://www.conorhalpin.eu:8080/job/MessageBroker/badge/icon'></a></p>
        <p>...</p>
        <p><b>Message Broker Api</b></p>
        <p>...</p>
        
        <br />
        <div align="center">
            <h3>The Academy - Final Year Project</h3>
        </div>
        <div align="center"><h4>• First person target shooting game</h4></div>
        <style>
            .embed-container {
                position: relative;
                padding-bottom: 56.25%;
                height: 0;
                overflow: hidden;
                max-width: 100%;
            }

                .embed-container iframe, .embed-container object, .embed-container embed {
                    position: absolute;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                }
        </style><div class='embed-container'><iframe src='https://www.youtube.com/embed/sf2liWaX2Rw' frameborder='0' allowfullscreen></iframe></div>
    </div>

    <fieldset>
        <legend>Comments</legend>
        <fieldset>
                @{Html.RenderPartial("~/Views/Comment/CreateComment.cshtml", new MvcWebsite.Models.CommentModel("Projects"));}
        </fieldset>
        @{Html.RenderPartial("~/Views/Comment/CommentList.cshtml");}
    </fieldset>

</body>
</html>